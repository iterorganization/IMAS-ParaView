"""
The IMAS GGD interface for ParaView.
This plugin targets the data dictionary version: {{ dd_ver }} and the UAL version: {{ ual_ver }}
Generated on {{ now() }}.

{{ warning_msg }}
"""

import datetime
import getpass
import imas
import numpy as np
import os
import platform

import paraview
from paraview.util.vtkAlgorithm import smproxy, smproperty, smdomain, smhint
from vtkmodules.util.vtkAlgorithm import VTKPythonAlgorithmBase
from vtkmodules.vtkCommonCore import vtkDataArray, vtkPoints
from vtkmodules.vtkCommonDataModel import vtkCellData, vtkCompositeDataSet, vtkDataAssembly, vtkDataObject, \
    vtkPartitionedDataSetCollection, vtkPointSet, vtkUnstructuredGrid
from vtkggdtools.errors import InvalidIDSIOError, InvalidIDSParametersError
from vtkggdtools.io import read_geom, write_geom, read_ps, write_ps
from vtkggdtools.io.representables import GridSubsetRepresentable
from vtkggdtools.imashelper import imas_env_call
from vtkggdtools._version import __version__ as vtkggdtools_ver

from identifiers.ggd_space_identifier import ggd_space_identifier

python_version = "Python-" + platform.python_version() + \
    " [Compiler - " + platform.python_compiler() + "]"
{% for name, ids in ids_blueprints | dictsort %}


@smproxy.source(label="{{ ids.label }} GGDReader")
@smhint.xml("""<ShowInMenu category="VTKGGDTools" />""")
class {{ ids.label }}GGDReader(VTKPythonAlgorithmBase):
    """
    This class wraps up the core IMAS GGDReader for the {{ ids.name }} IDS.
    """
    def __init__(self):
        VTKPythonAlgorithmBase.__init__(self,
                                        nInputPorts=0,
                                        nOutputPorts=1,
                                        outputType='vtkPartitionedDataSetCollection')
        self.__ISDName = "{{ ids.name }}"
        self.__Backend = {{ default.backend }}
        self.__Shot = {{ default.shot }}
        self.__Run = {{ default.run }}
        self.__UserName = "{{ default.username }}"
        self.__Tokamak = "{{ default.tokamak }}"
        self.__ImasMajorVer = "{{ default.major_ver }}"
        self.__Occurrence = {{ default.occurrence }}
        self.__GridGgdPath = {{ ids.grid_ggd_path }}

        self.__AosIndices = {}
        self.__AosIndexValues = {}
        {% for key, value in ids.aos_indices | dictsort %}
        self.__AosIndices.update({"{{ key }}": "{{ value }}"})
        self.__AosIndexValues.update({"{{ value }}": 0})
        {% endfor %}

    @smproperty.xml("""
        <IntVectorProperty command="SetBackend" 
                           default_values="{{ default.backend }}" 
                           name="Backend"
                           number_of_elements="1">
            <EnumerationDomain name="enum">
            {% for key, value in default.imas_backends | dictsort %} 
                <Entry text="{{ key }}" value="{{ value }}" />
            {% endfor %}
            </EnumerationDomain>
            <Documentation>This property determines the file-system backend for IMAS.</Documentation>
        </IntVectorProperty>""")
    def SetBackend(self, backend):
        if backend != self.__Backend:
            self.__Backend = backend
            self.Modified()

    @smproperty.intvector(name="Shot", default_values={{ default.shot }})
    def SetShot(self, val):
        if val != self.__Shot:
            self.__Shot = val
            self.Modified()

    @smproperty.intvector(name="Run", default_values={{ default.run }})
    def SetRun(self, val):
        if val != self.__Run:
            self.__Run = val
            self.Modified()

    @smproperty.stringvector(name="UserName", default_values="{{ default.username }}")
    def SetUserName(self, val):
        if val != self.__UserName:
            self.__UserName = val
            self.Modified()

    @smproperty.stringvector(name="Tokamak", default_values="{{ default.tokamak }}")
    def SetTokamak(self, val):
        if val != self.__Tokamak:
            self.__Tokamak = val
            self.Modified()

    @smproperty.stringvector(name="ImasMajorVer", default_values="{{ default.major_ver }}")
    def SetImasMajorVer(self, val):
        if val != self.__ImasMajorVer:
            self.__ImasMajorVer = val
            self.Modified()

    @smproperty.intvector(name="Occurrence", default_values={{ default.occurrence }})
    def SetOccurrence(self, val):
        if val != self.__Occurrence:
            self.__Occurrence = val
            self.Modified()
{% for key, value in ids.aos_indices | dictsort %}

    @smproperty.intvector(name="{{ value }}", default_values=0)
    def Set{{ value }}(self, val):
        if val != self.__AosIndexValues["{{ value }}"]:
            self.__AosIndexValues["{{ value }}"] = val
            self.Modified()
{% endfor %}

    def FillOutputPortInformation(self, port, info):
        info.Set(vtkDataObject.DATA_TYPE_NAME(), "vtkPartitionedDataSetCollection")
        return 1

    def RequestDataObject(self, port, inInfo, outInfo):
        output = vtkPartitionedDataSetCollection()
        outInfo.GetInformationObject(0).Set(vtkDataObject.DATA_OBJECT(), output)
        outInfo.GetInformationObject(0).Set(vtkDataObject.DATA_EXTENT_TYPE(), output.GetExtentType())
        return 1

    def RequestData(self, request, inInfo, outInfo):

        output = vtkPartitionedDataSetCollection.GetData(outInfo)
        ids_hdl = imas.ids(self.__Shot, self.__Run)

        try:
            imas_env_call(ids_hdl.open_env_backend, self.__UserName, self.__Tokamak,
                          self.__ImasMajorVer, self.__Backend)
        except InvalidIDSIOError as e:
            paraview.logger.exception(e)
            return 0

        ids_obj = ids_hdl.{{ ids.name }}
        ids_obj.time = ids_hdl.{{ ids.name }}.partialGet("time", self.__Occurrence)

        try:
            assert ids_obj.time is not None
        except AssertionError:
            e = InvalidIDSParametersError(shot=self.__Shot, run=self.__Run, user=self.__UserName,
                                          tokamak=self.__Tokamak, imas_major_ver=self.__ImasMajorVer,
                                          occurrence=self.__Occurrence)
            paraview.logger.exception(e)
            return 0

        tip = ids_obj

        paraview.logger.info(f"AosIndices: {self.__AosIndices}")
        paraview.logger.info(f"AosIndexValues: {self.__AosIndexValues}")
        ids_obj.get()
        paraview.logger.info('get call finished')

        for i, node_name in enumerate(self.__GridGgdPath):
            aos_idx_var = self.__AosIndices.get(node_name)

            if aos_idx_var is not None:
                aos = getattr(tip, node_name)
                aos_idx_val = self.__AosIndexValues[aos_idx_var]

                if aos_idx_val < len(aos):
                    tip = aos[aos_idx_val]
                else:
                    tip = None
                    break
            else:
                struct = getattr(tip, node_name)
                tip = struct

        paraview.logger.info(f'tip: {type(tip)}')
        if tip is not ids_obj and tip is not None:
            grid_ggd = tip
            paraview.logger.info(f'grid_ggd: {type(grid_ggd)}')
        else:
            paraview.logger.error('Failed to find a grid_ggd node.')
            return 0

        # We now have the grid_ggd
        num_subsets = len(grid_ggd.grid_subset)
        assembly = vtkDataAssembly()
        output.SetNumberOfPartitionedDataSets(num_subsets)
        output.SetDataAssembly(assembly)
        points = vtkPoints()
        space_idx = 0
        read_geom.fill_vtk_points(grid_ggd, space_idx, points)

        for subset_idx in range(num_subsets):
            subset = grid_ggd.grid_subset[subset_idx]
            paraview.logger.info(f"Processing subset {subset_idx}")
            paraview.logger.info(f"           index {subset.identifier.index}")
            paraview.logger.info(f"           name {subset.identifier.name}")
            paraview.logger.info(f"           description {subset.identifier.description}")
            ugrid = read_geom.convert_grid_subset_geometry_to_unstructured_grid(grid_ggd, subset_idx, points)
            read_ps.read_plasma_state('{{ ids.name }}', ids_obj, self.__AosIndexValues, subset_idx, ugrid)
            output.SetPartition(subset_idx, 0, ugrid)

            label = ''.join([text.capitalize() for text in subset.identifier.name.split()])
            child = assembly.AddNode(label, 0)
            assembly.AddDataSetIndex(child, subset_idx)
            output.GetMetaData(subset_idx).Set(vtkCompositeDataSet.NAME(), label)

        return 1
{% endfor %}
{% for name, ids in ids_blueprints | dictsort %}


@smproxy.filter(label="{{ ids.label }} GGDWriter")
@smhint.xml("""<ShowInMenu category="VTKGGDTools" />""")
@smproperty.input(name="Input", port_index=0)
@smdomain.datatype(dataTypes=["vtkPointSet"], composite_data_supported=True)
class {{ ids.label }}GGDWriter(VTKPythonAlgorithmBase):
    """
    This class wraps up the core IMAS GGDWriter for the {{ ids.name }} IDS.
    """
    def __init__(self):
        VTKPythonAlgorithmBase.__init__(self,
                                        nInputPorts=1,
                                        nOutputPorts=1,
                                        inputType='vtkPointSet',
                                        outputType='vtkUnstructuredGrid')
        self.__ISDName = "{{ ids.name }}"
        self.__Backend = {{ default.backend }}
        self.__Shot = {{ default.shot }}
        self.__Run = {{ default.run }}
        self.__UserName = "{{ default.username }}"
        self.__Tokamak = "{{ default.tokamak }}"
        self.__ImasMajorVer = "{{ default.major_ver }}"
        self.__Occurrence = {{ default.occurrence }}
        self.__GridGgdPath = {{ ids.grid_ggd_path }}
        self.__SourceString = 'Written by VTKGGDTools'
        self.__GridGGDType = {{ default.ggd_type }}
        self.__GridGGDSpaceType = {{ default.ggd_space_type }}

        self.__AosIndices = {}
        self.__AosIndexValues = {}
        {% for key, value in ids.aos_indices | dictsort %}
        self.__AosIndices.update({"{{ key }}": "{{ value }}"})
        self.__AosIndexValues.update({"{{ value }}": 0})
        {% endfor %}

    @smproperty.xml("""
        <IntVectorProperty command="SetBackend" 
                           default_values="{{ default.backend }}" 
                           name="Backend"
                           number_of_elements="1">
            <EnumerationDomain name="enum">
            {% for key, value in default.imas_backends | dictsort %} 
                <Entry text="{{ key }}" value="{{ value }}" />
            {% endfor %}
            </EnumerationDomain>
            <Documentation>This property determines the file-system backend for IMAS.</Documentation>
        </IntVectorProperty>""")
    def SetBackend(self, backend):
        if backend != self.__Backend:
            self.__Backend = backend
            self.Modified()

    @smproperty.xml("""
        <IntVectorProperty command="SetGridGGDType" 
                           default_values="{{ default.ggd_type }}" 
                           name="GridGGDType"
                           number_of_elements="1">
            <EnumerationDomain name="enum">
            {% for key, value in default.ggd_types | dictsort %} 
                <Entry text="{{ key }}" value="{{ value.get('index') }}" />
            {% endfor %}
            </EnumerationDomain>
            <Documentation>This property determines the grid ggd type.</Documentation>
        </IntVectorProperty>""")
    def SetGridGGDType(self, val):
        if val != self.__GridGGDType:
            self.__GridGGDType = val
            self.Modified()

    @smproperty.xml("""
        <IntVectorProperty command="SetGridGGDSpaceType" 
                           default_values="{{ default.ggd_space_type }}" 
                           name="GridGGDSpaceType"
                           number_of_elements="1">
            <EnumerationDomain name="enum">
            {% for key, value in default.ggd_space_types | dictsort %} 
                <Entry text="{{ key }}" value="{{ value.get('index') }}" />
            {% endfor %}
            </EnumerationDomain>
            <Documentation>This property determines the space type for the grid ggd geometry.</Documentation>
        </IntVectorProperty>""")
    def SetGridGGDSpaceType(self, val):
        if val != self.__GridGGDSpaceType:
            self.__GridGGDSpaceType = val
            self.Modified()

    @smproperty.intvector(name="Shot", default_values={{ default.shot }})
    def SetShot(self, val):
        if val != self.__Shot:
            self.__Shot = val
            self.Modified()

    @smproperty.intvector(name="Run", default_values={{ default.run }})
    def SetRun(self, val):
        if val != self.__Run:
            self.__Run = val
            self.Modified()

    @smproperty.stringvector(name="UserName", default_values="{{ default.username }}")
    def SetUserName(self, val):
        if val != self.__UserName:
            self.__UserName = val
            self.Modified()

    @smproperty.stringvector(name="Tokamak", default_values="{{ default.tokamak }}")
    def SetTokamak(self, val):
        if val != self.__Tokamak:
            self.__Tokamak = val
            self.Modified()

    @smproperty.stringvector(name="ImasMajorVer", default_values="{{ default.major_ver }}")
    def SetImasMajorVer(self, val):
        if val != self.__ImasMajorVer:
            self.__ImasMajorVer = val
            self.Modified()

    @smproperty.intvector(name="Occurrence", default_values={{ default.occurrence }})
    def SetOccurrence(self, val):
        if val != self.__Occurrence:
            self.__Occurrence = val
            self.Modified()
{% for key, value in ids.aos_indices | dictsort %}

    @smproperty.intvector(name="{{ value }}", default_values=0)
    def Set{{ value }}(self, val):
        if val != self.__AosIndexValues["{{ value }}"]:
            self.__AosIndexValues["{{ value }}"] = val
            self.Modified()
{% endfor %}

    @smproperty.stringvector(name="SourceString", default_values="Written by VTKGGDTools")
    def SetSourceString(self, val):
        if val != self.__SourceString:
            self.__SourceString = val
            self.Modified()

    def FillInputPortInformation(self, port, info):
        info.Set(vtkDataObject.DATA_TYPE_NAME(), "vtkPointSet")
        return 1

    def FillOutputPortInformation(self, port, info):
        info.Set(vtkDataObject.DATA_TYPE_NAME(), "vtkUnstructuredGrid")
        return 1

    def RequestDataObject(self, request, inInfo, outInfo):
        output = vtkUnstructuredGrid()
        outInfo.GetInformationObject(0).Set(vtkDataObject.DATA_OBJECT(), output)
        outInfo.GetInformationObject(0).Set(vtkDataObject.DATA_EXTENT_TYPE(), output.GetExtentType())
        return 1

    def RequestData(self, request, inInfo, outInfo):

        input0 = vtkPointSet.GetData(inInfo[0])
        output = vtkUnstructuredGrid.GetData(outInfo)
        cell_data: vtkCellData = input0.GetCellData()

        ids_hdl = imas.ids(self.__Shot, self.__Run)

        try:
            imas_env_call(ids_hdl.open_env_backend, self.__UserName, self.__Tokamak,
                          self.__ImasMajorVer, self.__Backend)
        except InvalidIDSIOError:
            try:
                imas_env_call(ids_hdl.create_env_backend, self.__UserName, self.__Tokamak,
                              self.__ImasMajorVer, self.__Backend)
                paraview.logger.info(f"Created a new IDS ({self.__Shot}, {self.__Run}) User: {self.__UserName}, "
                                     f"Tokamak: {self.__Tokamak}")
            except Exception as e:
                paraview.logger.exception(e)
                return 0

        ids_obj = ids_hdl.{{ ids.name }}
        ids_obj.get(self.__Occurrence)
        paraview.logger.info(self.__AosIndices)
        paraview.logger.info(self.__AosIndexValues)
        paraview.logger.info('get call done')

        if ids_obj.ids_properties.homogeneous_time < 0:
            ids_obj.ids_properties.homogeneous_time = 1
            ids_obj.ids_properties.source = self.__SourceString
            ids_obj.ids_properties.provider = getpass.getuser()
            ids_obj.ids_properties.creation_date = str(datetime.datetime.today())
            ids_obj.ids_properties.version_put.data_dictionary = os.getenv('IMAS_VERSION')
            ids_obj.ids_properties.version_put.access_layer = os.getenv('UAL_VERSION')
            ids_obj.ids_properties.version_put.access_layer_language = python_version

            ids_obj.code.name = 'VTKGGDTools'
            ids_obj.code.version = vtkggdtools_ver
            ids_obj.code.repository = "https://git.iter.org/scm/imex/ggd-vtk.git"
            ids_obj.code.output_flag = np.array([0])

        if not len(ids_obj.time):
            ids_obj.time.resize(1)
            ids_obj.time[0] = 0.0

        # Begin reading the grid_ggd
        tip = ids_obj

        for i, node_name in enumerate(self.__GridGgdPath):
            aos_idx_var = self.__AosIndices.get(node_name)

            if aos_idx_var is not None:
                aos = getattr(tip, node_name)
                aos_idx_val = self.__AosIndexValues[aos_idx_var]

                if aos_idx_val >= len(aos):
                    aos.resize(aos_idx_val + 1, keep=True)

                tip = aos[aos_idx_val]
            else:
                struct = getattr(tip, node_name)
                tip = struct

        paraview.logger.info(f'tip: {type(tip)}')
        if tip is not ids_obj and tip is not None:
            grid_ggd = tip
            paraview.logger.info(f'grid_ggd: {type(grid_ggd)}')
        else:
            paraview.logger.error('Failed to find a grid_ggd node.')
            return 0

        # We now have the grid_ggd
        # 1. Populate the space AoS
        num_subsets = cell_data.GetNumberOfArrays() + 4
        grid_ggd.grid_subset.resize(num_subsets) #Implicit: nodes, edges, cells, volumes
        grid_ggd.space.resize(1)
        space_idx = 0
        paraview.logger.info(f"Populating grid_ggd/space[{space_idx}]")

        space_name = list(ggd_space_identifier.keys())[self.__GridGGDSpaceType]
        grid_ggd.space[space_idx].identifier.name = space_name
        grid_ggd.space[space_idx].identifier.index = self.__GridGGDSpaceType
        grid_ggd.space[space_idx].identifier.description = ggd_space_identifier.get(space_name).get('description')

        # Fill up space with 0,1,2,3 d geometry from the first partition.
        # It is assumed all other partitions share same points.
        paraview.logger.info(f"Populating basic grid_subsets")
        grid_ggd_rep = write_geom.fill_grid_ggd_basic_geometry(input0, space_idx, grid_ggd)
        output.ShallowCopy(grid_ggd_rep.ugrid)
        subset_rep = GridSubsetRepresentable(ugrid=grid_ggd_rep.ugrid, num_subsets=num_subsets)

        # 2. Populate the grid_subset AoS
        # Every partitioned dataset goes into its own grid_subset.
        for subset_idx in range(4, num_subsets):
            data_array: vtkDataArray = cell_data.GetArray(subset_idx - 4)
            subset_name = data_array.GetName()
            write_geom.convert_vtk_dataset_to_grid_subset_geometry(grid_ggd_rep, subset_rep, space_idx, subset_idx,
                                                                   subset_name, grid_ggd)
        write_ps.write_plasma_state('{{ ids.name }}', ids_obj, self.__AosIndexValues, space_idx,
                                    grid_ggd_rep, subset_rep, grid_ggd)
        ids_obj.put(self.__Occurrence)
        ids_hdl.close()

        return 1

    def Write(self):
        self.Modified()
        self.Update()
{% endfor %}