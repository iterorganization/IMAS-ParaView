"""
The IMAS GGD interface for ParaView.
This plugin targets the data dictionary version: {{ dd_ver }} and the UAL version: {{ ual_ver }}
Generated on {{ now() }}.

{{ warning_msg }}
"""

import datetime
import getpass
import imas
import numpy as np
import os
import platform

import paraview
from paraview.util.vtkAlgorithm import smproxy, smproperty, smdomain, smhint
from vtkmodules.util.vtkAlgorithm import VTKPythonAlgorithmBase
from vtkmodules.vtkCommonCore import vtkDataArray, vtkPoints
from vtkmodules.vtkCommonDataModel import vtkCellData, vtkCompositeDataSet, vtkDataAssembly, vtkDataObject, \
    vtkPartitionedDataSetCollection, vtkPointSet, vtkUnstructuredGrid
from vtkggdtools.errors import InvalidIDSIOError, InvalidIDSParametersError
from vtkggdtools.io import read_geom, read_bezier, write_geom, read_ps, write_ps
from vtkggdtools.io.representables import GridSubsetRepresentable
from vtkggdtools.imashelper import imas_env_call
from vtkggdtools._version import get_versions

from identifiers.ggd_space_identifier import ggd_space_identifier

python_version = "Python-" + platform.python_version() + \
    " [Compiler - " + platform.python_compiler() + "]"
    
{% for name, ids in ids_blueprints | dictsort %}

@smproxy.source(label="{{ ids.label }} GGDReader")
@smhint.xml("""<ShowInMenu category="VTKGGDTools" />""")
class {{ ids.label }}GGDReader(VTKPythonAlgorithmBase):
    """
    This class wraps up the core IMAS GGDReader for the {{ ids.name }} IDS.
    """
    def __init__(self):
        VTKPythonAlgorithmBase.__init__(self,
                                        nInputPorts=0,
                                        nOutputPorts=1,
                                        outputType='vtkPartitionedDataSetCollection')
        self.__ISDName = "{{ ids.name }}"
        self.__Backend = {{ default.backend }}
        self.__Shot = {{ default.shot }}
        self.__Run = {{ default.run }}
        self.__UserName = "{{ default.username }}"
        self.__Tokamak = "{{ default.tokamak }}"
        self.__ImasMajorVer = "{{ default.major_ver }}"
        self.__Occurrence = {{ default.occurrence }}
        self.__GridGgdPath = {{ ids.grid_ggd_path }}
    {% if ids.name in ['mhd', 'radiation']%}        
        self.__n_plane = {{ default.n_plane }}
        self.__phi_start = {{ default.phi_start }}
        self.__phi_end = {{ default.phi_end }}
    {% endif %}

        self.__AosIndices = {}
        self.__AosIndexValues = {}
        {% for key, value in ids.aos_indices | dictsort %}
        self.__AosIndices.update({"{{ key }}": "{{ value }}"})
        self.__AosIndexValues.update({"{{ value }}": 0})
        {% endfor %}
        # {% if ids.name == "edge_transport" %}
        # self.__AosIndices.update({"model": "ModelIdx"})
        # self.__AosIndexValues.update({"ModelIdx": "to be parsed"})
        # {% endif %}

    @smproperty.xml("""
        <IntVectorProperty command="SetBackend" 
                           default_values="{{ default.backend }}" 
                           name="Backend"
                           number_of_elements="1">
            <EnumerationDomain name="enum">
            {% for key, value in default.imas_backends | dictsort %} 
                <Entry text="{{ key }}" value="{{ value }}" />
            {% endfor %}
            </EnumerationDomain>
            <Documentation>This property determines the file-system backend for IMAS.</Documentation>
        </IntVectorProperty>""")
    def SetBackend(self, backend):
        if backend != self.__Backend:
            self.__Backend = backend
            self.Modified()

    @smproperty.intvector(name="Shot", default_values={{ default.shot }})
    def SetShot(self, val):
        if val != self.__Shot:
            self.__Shot = val
            self.Modified()

    @smproperty.intvector(name="Run", default_values={{ default.run }})
    def SetRun(self, val):
        if val != self.__Run:
            self.__Run = val
            self.Modified()

    @smproperty.stringvector(name="UserName", default_values="{{ default.username }}")
    def SetUserName(self, val):
        if val != self.__UserName:
            self.__UserName = val
            self.Modified()

    @smproperty.stringvector(name="Tokamak", default_values="{{ default.tokamak }}")
    def SetTokamak(self, val):
        if val != self.__Tokamak:
            self.__Tokamak = val
            self.Modified()

    @smproperty.stringvector(name="ImasMajorVer", default_values="{{ default.major_ver }}")
    def SetImasMajorVer(self, val):
        if val != self.__ImasMajorVer:
            self.__ImasMajorVer = val
            self.Modified()

    @smproperty.intvector(name="Occurrence", default_values={{ default.occurrence }})
    def SetOccurrence(self, val):
        if val != self.__Occurrence:
            self.__Occurrence = val
            self.Modified()
{% for key, value in ids.aos_indices | dictsort %}

    @smproperty.intvector(name="{{ value }}", default_values=0)
    def Set{{ value }}(self, val):
        if val != self.__AosIndexValues["{{ value }}"]:
            self.__AosIndexValues["{{ value }}"] = val
            self.Modified()
{% endfor %}

    {% if ids.name in ['mhd', 'radiation']%}
    @smproperty.intvector(name="N plane", default_values={{ default.n_plane }})
    def SetNPlane(self, val):
        if val != self.__n_plane:
            self.__n_plane = val
            self.Modified()

    @smproperty.doublevector(name="Phi Range", default_values=[{{ default.phi_start }}, {{ default.phi_end }}])
    @smdomain.doublerange(min=0, max=360.0)
    def SetPhiRange(self, val, val2):
        if val != self.__phi_start:
            self.__phi_start = val
            self.Modified()
        if val2 != self.__phi_end:
            self.__phi_end = val2
            self.Modified()
    {% endif %}


    def FillOutputPortInformation(self, port, info):
        info.Set(vtkDataObject.DATA_TYPE_NAME(), "vtkPartitionedDataSetCollection")
        return 1

    def RequestDataObject(self, port, inInfo, outInfo):
        output = vtkPartitionedDataSetCollection()
        outInfo.GetInformationObject(0).Set(vtkDataObject.DATA_OBJECT(), output)
        outInfo.GetInformationObject(0).Set(vtkDataObject.DATA_EXTENT_TYPE(), output.GetExtentType())
        return 1

    def RequestData(self, request, inInfo, outInfo):

        output = vtkPartitionedDataSetCollection.GetData(outInfo)
        ids_hdl = imas.ids(self.__Shot, self.__Run)

        try:
            imas_env_call(ids_hdl.open_env_backend, self.__UserName, self.__Tokamak,
                          self.__ImasMajorVer, self.__Backend)
        except InvalidIDSIOError as e:
            paraview.logger.exception(e)
            return 0

        ids_obj = ids_hdl.{{ ids.name }}
        ids_obj.time = ids_hdl.{{ ids.name }}.partialGet("time", self.__Occurrence)

        try:
            assert ids_obj.time is not None
        except AssertionError:
            e = InvalidIDSParametersError(shot=self.__Shot, run=self.__Run, user=self.__UserName,
                                          tokamak=self.__Tokamak, imas_major_ver=self.__ImasMajorVer,
                                          occurrence=self.__Occurrence)
            paraview.logger.exception(e)
            return 0

        tip = ids_obj

        paraview.logger.info(f"AosIndices: {self.__AosIndices}")
        paraview.logger.info(f"AosIndexValues: {self.__AosIndexValues}")
        ids_obj.get()
        paraview.logger.info('get call finished')

        for i, node_name in enumerate(self.__GridGgdPath):
            aos_idx_var = self.__AosIndices.get(node_name)

            if aos_idx_var is not None:
                aos = getattr(tip, node_name)
                aos_idx_val = self.__AosIndexValues[aos_idx_var]

                if aos_idx_val < len(aos):
                    tip = aos[aos_idx_val]
                else:
                    tip = None
                    break
            else:
                struct = getattr(tip, node_name)
                tip = struct

        paraview.logger.info(f'tip: {type(tip)}')
        if tip is not ids_obj and tip is not None:
            grid_ggd = tip
            paraview.logger.info(f'grid_ggd: {type(grid_ggd)}')
        else:
            paraview.logger.error('Failed to find a grid_ggd node.')
            return 0

        # We now have the grid_ggd
        {% if ids.name == 'wall'%}
        #grid_ggd = grid_ggd.grid_ggd[0]
        #For mesh IDS from smiter
        {% endif %}
        num_subsets = len(grid_ggd.grid_subset)
        points = vtkPoints()
        space_idx = 0

        # Check if we have anything to read:
        if num_subsets < 1 and len(grid_ggd.space) < 1:
            paraview.logger.info('No points to read from grid_ggd')
            return 0

        {% if ids.name in ['mhd', 'radiation']%}
        assembly = vtkDataAssembly()
        output.SetNumberOfPartitionedDataSets(num_subsets)
        output.SetDataAssembly(assembly)

        if self.__n_plane != 0:
            number_of_spaces = len(grid_ggd.space)
            if number_of_spaces > 1 and len(grid_ggd.space[0].coordinates_type) == 2:
                n_period = grid_ggd.space[1].geometry_type.index
                # print(f'Number of spaces: {number_of_spaces}, Periodicity {n_period}')
                if n_period > 0: # Fourier space with periodicity (JOREK)
                    paraview.logger.info(f'Reading Bezier mesh with Fourier periodiciy {n_period}')
                    ugrid = read_bezier.convert_grid_subset_to_unstructured_grid('{{ ids.name }}', ids_obj, self.__AosIndexValues, self.__n_plane, self.__phi_start, self.__phi_end)
                    output.SetPartition(0, 0, ugrid)
                    child = assembly.AddNode('{{ ids.name }}', 0)
                    assembly.AddDataSetIndex(child, 0)
                    output.GetMetaData(0).Set(vtkCompositeDataSet.NAME(), '{{ ids.name }}')
                else:
                    paraview.logger.error(f'Number of planes {self.__n_plane} invalid for this {number_of_spaces} number of spaces')
            else:
                paraview.logger.error(f'Number of planes {self.__n_plane} invalid for this IDS type. Try using N = 0')
        else:
            if len(grid_ggd.space) < 1:
                paraview.logger.info('No points to read from grid_ggd.space')
            else:
                read_geom.fill_vtk_points(grid_ggd, space_idx, points, '{{ ids.name }}')
            if num_subsets < 1:
                    paraview.logger.info('No subsets to read from grid_ggd')
            else:
                for subset_idx in range(num_subsets):
                    subset = grid_ggd.grid_subset[subset_idx]
                    paraview.logger.info(f"Processing subset {subset_idx}")
                    paraview.logger.info(f"           index {subset.identifier.index}")
                    paraview.logger.info(f"           name {subset.identifier.name}")
                    paraview.logger.info(f"           description {subset.identifier.description}")          
                    if self.__n_plane == 0 or subset_idx == 0: # Regular grid processing
                        ugrid = read_geom.convert_grid_subset_geometry_to_unstructured_grid(grid_ggd, subset_idx, points)
                        read_ps.read_plasma_state('{{ ids.name }}', ids_obj, self.__AosIndexValues, subset_idx, ugrid)
                    output.SetPartition(subset_idx, 0, ugrid)
                    label = subset.identifier.name
                    child = assembly.AddNode(label.replace(' ', '_'), 0)
                    assembly.AddDataSetIndex(child, subset_idx)
                    output.GetMetaData(subset_idx).Set(vtkCompositeDataSet.NAME(), label)
                    self.UpdateProgress(self.GetProgress()+1/num_subsets)
        {% elif ids.name == 'wall' %}
        read_geom.fill_vtk_points(grid_ggd, space_idx, points, '{{ ids.name }}')
        # Process grid_ggd.subsets:
        if num_subsets <= 1:
            paraview.logger.info('No subsets to read from grid_ggd')
            assembly = vtkDataAssembly()
            output.SetNumberOfPartitionedDataSets(1)
            output.SetDataAssembly(assembly)
            ugrid = read_geom.convert_grid_subset_geometry_to_unstructured_grid(grid_ggd, -1, points)
            read_ps.read_plasma_state('{{ ids.name }}', ids_obj, self.__AosIndexValues, -1, ugrid)
            output.SetPartition(0, 0, ugrid)
            label = '{{ ids.name }}'
            child = assembly.AddNode(label, 0)
            assembly.AddDataSetIndex(child, 0)
            output.GetMetaData(0).Set(vtkCompositeDataSet.NAME(), label)
        else:
            assembly = vtkDataAssembly()
            output.SetNumberOfPartitionedDataSets(num_subsets - 3)
            output.SetDataAssembly(assembly)
            ugrid = read_geom.convert_grid_subset_geometry_to_unstructured_grid(grid_ggd, -1, points)
            read_ps.read_plasma_state('{{ ids.name }}', ids_obj, self.__AosIndexValues, -1, ugrid)
            output.SetPartition(0, 0, ugrid)
            label = '{{ ids.name }}'
            child = assembly.AddNode(label, 0)
            assembly.AddDataSetIndex(child, 0)
            output.GetMetaData(0).Set(vtkCompositeDataSet.NAME(), label)
            for subset_idx in range(4, num_subsets):
                subset = grid_ggd.grid_subset[subset_idx]
                paraview.logger.info(f"Processing subset {subset_idx}")
                paraview.logger.info(f"           index {subset.identifier.index}")
                paraview.logger.info(f"           name {subset.identifier.name}")
                paraview.logger.info(f"           description {subset.identifier.description}")
                ugrid = read_geom.convert_grid_subset_geometry_to_unstructured_grid(grid_ggd, subset_idx, points)
                read_ps.read_plasma_state('{{ ids.name }}', ids_obj, self.__AosIndexValues, subset_idx, ugrid)
                output.SetPartition(subset_idx - 3, 0, ugrid)
                label = subset.identifier.name
                child = assembly.AddNode(label.replace(' ', '_'), 0)
                assembly.AddDataSetIndex(child, subset_idx - 3)
                output.GetMetaData(subset_idx - 3).Set(vtkCompositeDataSet.NAME(), label)
                self.UpdateProgress(self.GetProgress()+1/num_subsets)

        {% else %}
        read_geom.fill_vtk_points(grid_ggd, space_idx, points, '{{ ids.name }}')
        # Process grid_ggd.subsets:
        if num_subsets <= 1:
            paraview.logger.info('No subsets to read from grid_ggd')
            assembly = vtkDataAssembly()
            output.SetNumberOfPartitionedDataSets(1)
            output.SetDataAssembly(assembly)
            ugrid = read_geom.convert_grid_subset_geometry_to_unstructured_grid(grid_ggd, -1, points)
            read_ps.read_plasma_state('{{ ids.name }}', ids_obj, self.__AosIndexValues, -1, ugrid)
            output.SetPartition(0, 0, ugrid)
            label = '{{ ids.name }}'
            child = assembly.AddNode(label, 0)
            assembly.AddDataSetIndex(child, 0)
            output.GetMetaData(0).Set(vtkCompositeDataSet.NAME(), label)
        else:
            assembly = vtkDataAssembly()
            output.SetNumberOfPartitionedDataSets(num_subsets)
            output.SetDataAssembly(assembly)
            for subset_idx in range(num_subsets):
                subset = grid_ggd.grid_subset[subset_idx]
                paraview.logger.info(f"Processing subset {subset_idx}")
                paraview.logger.info(f"           index {subset.identifier.index}")
                paraview.logger.info(f"           name {subset.identifier.name}")
                paraview.logger.info(f"           description {subset.identifier.description}")
                ugrid = read_geom.convert_grid_subset_geometry_to_unstructured_grid(grid_ggd, subset_idx, points)
                read_ps.read_plasma_state('{{ ids.name }}', ids_obj, self.__AosIndexValues, subset_idx, ugrid)
                output.SetPartition(subset_idx, 0, ugrid)
                label = subset.identifier.name
                child = assembly.AddNode(label.replace(' ', '_'), 0)
                assembly.AddDataSetIndex(child, subset_idx)
                output.GetMetaData(subset_idx).Set(vtkCompositeDataSet.NAME(), label)
                self.UpdateProgress(self.GetProgress()+1/num_subsets)
        {% endif %}

        # {% if ids.name == "edge_transport" %}
        # # models = dict()
        # # for idx in range(len(ids_obj.model)):
        # #     m = ids_obj.model[idx]
        # #     models[str(m.identifier.name)] = idx
        # # SetModelIdx(models)
        # {% endif %}
                
        return 1
{% endfor %}


{% for name, ids in ids_blueprints | dictsort %}
@smproxy.filter(label="{{ ids.label }} GGDWriter")
@smhint.xml("""<ShowInMenu category="VTKGGDTools" />""")
@smproperty.input(name="Input", port_index=0)
@smdomain.datatype(dataTypes=["vtkPointSet"], composite_data_supported=True)
class {{ ids.label }}GGDWriter(VTKPythonAlgorithmBase):
    """
    This class wraps up the core IMAS GGDWriter for the {{ ids.name }} IDS.
    """
    def __init__(self):
        VTKPythonAlgorithmBase.__init__(self,
                                        nInputPorts=1,
                                        nOutputPorts=1,
                                        inputType='vtkPointSet',
                                        outputType='vtkUnstructuredGrid')
        self.__ISDName = "{{ ids.name }}"
        self.__Backend = {{ default.backend }}
        self.__Shot = {{ default.shot }}
        self.__Run = {{ default.run }}
        self.__UserName = "{{ default.username }}"
        self.__Tokamak = "{{ default.tokamak }}"
        self.__ImasMajorVer = "{{ default.major_ver }}"
        self.__Occurrence = {{ default.occurrence }}
        self.__GridGgdPath = {{ ids.grid_ggd_path }}
        self.__GridGGDType = {{ default.ggd_type }}
        self.__GridGGDSpaceType = {{ default.ggd_space_type }}

        self.__AosIndices = {}
        self.__AosIndexValues = {}
        {% for key, value in ids.aos_indices | dictsort %}
        self.__AosIndices.update({"{{ key }}": "{{ value }}"})
        self.__AosIndexValues.update({"{{ value }}": 0})
        {% endfor %}
        # {% if ids.name == "edge_transport" %}
        # self.__AosIndices.update({"model": "ModelIdx"})
        # self.__AosIndexValues.update({"ModelIdx": "to be parsed"})
        # {% endif %}

    @smproperty.xml("""
        <IntVectorProperty command="SetBackend" 
                           default_values="{{ default.backend }}" 
                           name="Backend"
                           number_of_elements="1">
            <EnumerationDomain name="enum">
            {% for key, value in default.imas_backends | dictsort %} 
                <Entry text="{{ key }}" value="{{ value }}" />
            {% endfor %}
            </EnumerationDomain>
            <Documentation>This property determines the file-system backend for IMAS.</Documentation>
        </IntVectorProperty>""")
    def SetBackend(self, backend):
        if backend != self.__Backend:
            self.__Backend = backend
            self.Modified()

    @smproperty.xml("""
        <IntVectorProperty command="SetGridGGDType" 
                           default_values="{{ default.ggd_type }}" 
                           name="GridGGDType"
                           number_of_elements="1">
            <EnumerationDomain name="enum">
            {% for key, value in default.ggd_types | dictsort %} 
                <Entry text="{{ key }}" value="{{ value.get('index') }}" />
            {% endfor %}
            </EnumerationDomain>
            <Documentation>This property determines the grid ggd type.</Documentation>
        </IntVectorProperty>""")
    def SetGridGGDType(self, val):
        if val != self.__GridGGDType:
            self.__GridGGDType = val
            self.Modified()

    @smproperty.xml("""
        <IntVectorProperty command="SetGridGGDSpaceType" 
                           default_values="{{ default.ggd_space_type }}" 
                           name="GridGGDSpaceType"
                           number_of_elements="1">
            <EnumerationDomain name="enum">
            {% for key, value in default.ggd_space_types | dictsort %} 
                <Entry text="{{ key }}" value="{{ value.get('index') }}" />
            {% endfor %}
            </EnumerationDomain>
            <Documentation>This property determines the space type for the grid ggd geometry.</Documentation>
        </IntVectorProperty>""")
    def SetGridGGDSpaceType(self, val):
        if val != self.__GridGGDSpaceType:
            self.__GridGGDSpaceType = val
            self.Modified()

    @smproperty.intvector(name="Shot", default_values={{ default.shot }})
    def SetShot(self, val):
        if val != self.__Shot:
            self.__Shot = val
            self.Modified()

    @smproperty.intvector(name="Run", default_values={{ default.run }})
    def SetRun(self, val):
        if val != self.__Run:
            self.__Run = val
            self.Modified()

    @smproperty.stringvector(name="UserName", default_values="{{ default.username }}")
    def SetUserName(self, val):
        if val != self.__UserName:
            self.__UserName = val
            self.Modified()

    @smproperty.stringvector(name="Tokamak", default_values="{{ default.tokamak }}")
    def SetTokamak(self, val):
        if val != self.__Tokamak:
            self.__Tokamak = val
            self.Modified()

    @smproperty.stringvector(name="ImasMajorVer", default_values="{{ default.major_ver }}")
    def SetImasMajorVer(self, val):
        if val != self.__ImasMajorVer:
            self.__ImasMajorVer = val
            self.Modified()

    @smproperty.intvector(name="Occurrence", default_values={{ default.occurrence }})
    def SetOccurrence(self, val):
        if val != self.__Occurrence:
            self.__Occurrence = val
            self.Modified()
{% for key, value in ids.aos_indices | dictsort %}

    @smproperty.intvector(name="{{ value }}", default_values=0)
    def Set{{ value }}(self, val):
        if val != self.__AosIndexValues["{{ value }}"]:
            self.__AosIndexValues["{{ value }}"] = val
            self.Modified()
{% endfor %}
# {% if ids.name == "edge_transport" %}
#     @smproperty.intvector(name="ModelIdx", default_values="to be parsed")
#     def SetModelIdx(self, val):
#         if val != self.__AosIndexValues["ModelIdx"]:
#             self.__AosIndexValues["ModelIdx"] = val
#             self.Modified()
# {% endif %}

    def FillInputPortInformation(self, port, info):
        info.Set(vtkDataObject.DATA_TYPE_NAME(), "vtkPointSet")
        return 1

    def FillOutputPortInformation(self, port, info):
        info.Set(vtkDataObject.DATA_TYPE_NAME(), "vtkUnstructuredGrid")
        return 1

    def RequestDataObject(self, request, inInfo, outInfo):
        output = vtkUnstructuredGrid()
        outInfo.GetInformationObject(0).Set(vtkDataObject.DATA_OBJECT(), output)
        outInfo.GetInformationObject(0).Set(vtkDataObject.DATA_EXTENT_TYPE(), output.GetExtentType())
        return 1

    def RequestData(self, request, inInfo, outInfo):

        input0 = vtkPointSet.GetData(inInfo[0])
        output = vtkUnstructuredGrid.GetData(outInfo)
        cell_data: vtkCellData = input0.GetCellData()

        ids_hdl = imas.ids(self.__Shot, self.__Run)

        try:
            imas_env_call(ids_hdl.open_env_backend, self.__UserName, self.__Tokamak,
                          self.__ImasMajorVer, self.__Backend)
        except InvalidIDSIOError:
            try:
                imas_env_call(ids_hdl.create_env_backend, self.__UserName, self.__Tokamak,
                              self.__ImasMajorVer, self.__Backend)
                paraview.logger.info(f"Created a new IDS ({self.__Shot}, {self.__Run}) User: {self.__UserName}, "
                                     f"Tokamak: {self.__Tokamak}")
            except Exception as e:
                paraview.logger.exception(e)
                return 0

        ids_obj = ids_hdl.{{ ids.name }}
        ids_obj.get(self.__Occurrence)
        paraview.logger.info(self.__AosIndices)
        paraview.logger.info(self.__AosIndexValues)
        paraview.logger.info('get call done')

        if ids_obj.ids_properties.homogeneous_time < 0:
            ids_obj.ids_properties.homogeneous_time = 1
            ids_obj.ids_properties.provider = getpass.getuser()
            ids_obj.ids_properties.creation_date = str(datetime.datetime.today())

            ids_obj.code.name = 'VTKGGDTools'
            ids_obj.code.version = get_versions()['version']
            ids_obj.code.commit = get_versions()['full-revisionid']
            ids_obj.code.repository = "https://git.iter.org/scm/imex/ggd-vtk.git"
            ids_obj.code.output_flag = np.array([0])

        if not len(ids_obj.time):
            ids_obj.time.resize(1)
            ids_obj.time[0] = 0.0

        # Begin reading the grid_ggd
        tip = ids_obj

        for i, node_name in enumerate(self.__GridGgdPath):
            aos_idx_var = self.__AosIndices.get(node_name)

            if aos_idx_var is not None:
                aos = getattr(tip, node_name)
                aos_idx_val = self.__AosIndexValues[aos_idx_var]

                if aos_idx_val >= len(aos):
                    aos.resize(aos_idx_val + 1, keep=True)

                tip = aos[aos_idx_val]
            else:
                struct = getattr(tip, node_name)
                tip = struct

        paraview.logger.info(f'tip: {type(tip)}')
        if tip is not ids_obj and tip is not None:
            grid_ggd = tip
            paraview.logger.info(f'grid_ggd: {type(grid_ggd)}')
        else:
            paraview.logger.error('Failed to find a grid_ggd node.')
            return 0

        # We now have the grid_ggd
        # 1. Populate the space AoS
        num_subsets = cell_data.GetNumberOfArrays() + 4
        grid_ggd.grid_subset.resize(num_subsets) #Implicit: nodes, edges, cells, volumes
        grid_ggd.space.resize(1)
        space_idx = 0
        paraview.logger.info(f"Populating grid_ggd/space[{space_idx}]")

        space_name = list(ggd_space_identifier.keys())[self.__GridGGDSpaceType]
        grid_ggd.space[space_idx].identifier.name = space_name
        grid_ggd.space[space_idx].identifier.index = self.__GridGGDSpaceType
        grid_ggd.space[space_idx].identifier.description = ggd_space_identifier.get(space_name).get('description')

        # Fill up space with 0,1,2,3 d geometry from the first partition.
        # It is assumed all other partitions share same points.
        paraview.logger.info(f"Populating basic grid_subsets")
        grid_ggd_rep = write_geom.fill_grid_ggd_basic_geometry(input0, space_idx, grid_ggd)
        output.ShallowCopy(grid_ggd_rep.ugrid)
        subset_rep = GridSubsetRepresentable(ugrid=grid_ggd_rep.ugrid, num_subsets=num_subsets)

        # 2. Populate the grid_subset AoS
        # Every partitioned dataset goes into its own grid_subset.
        for subset_idx in range(4, num_subsets):
            data_array: vtkDataArray = cell_data.GetArray(subset_idx - 4)
            subset_name = data_array.GetName()
            write_geom.convert_vtk_dataset_to_grid_subset_geometry(grid_ggd_rep, subset_rep, space_idx, subset_idx,
                                                                   subset_name, grid_ggd)
        write_ps.write_plasma_state('{{ ids.name }}', ids_obj, self.__AosIndexValues, space_idx,
                                    grid_ggd_rep, subset_rep, grid_ggd)
        ids_obj.put(self.__Occurrence)
        ids_hdl.close()

        return 1

    def Write(self):
        self.Modified()
        self.Update()
{% endfor %}
